# CS497-HW6
1. This algorithm first stores all of the edges in a hashmap for quick lookup. It then performs a recursive depth first search on the graph, starting at the start node and then calling the function recursively on its children until either the end node is found, returning true, or there are no more children to be searched, returning false. It also maintains a visited node set to ensure nodes arenâ€™t traversed repeatedly, checking against the set each time the recursive function is called. This program has a time complexity of O(N+M), where N is the number of vertices and M is the number of edges. Building the Map takes O(M) time, being called once on each edge in the array. The path checking is O(N), as it checks nodes in order and could potentially have to check all nodes. Space complexity is O(M), where M is again the number of edges, as the edges are stored in the Map.
2. This algorithm performs a version of a depth first search, visiting each node in the graph followed by all inodes it points to.  The time at which each node is visited is stored in an array. If a node has already been evaluated, we skip it. If the node currently being checked is reached, if the time is greater than or equal to the start time of the traversal, the difference between the current time and the previous visit time is the cycle length, which is stored. This value is checked against our current maximum cycle length, which is replaced if necessary. Once the whole graph has been traversed, the algorithm returns the maximum cycle length found. The time complexity is O(N), as it traverses the graph once, visiting each node. This algorithm also uses O(N) auxiliary space, to store the visit times of each node. 


4. This algorithm performs a version of a depth first search, visiting each node in the graph followed by all nodes it points to. It first creates an ArrayList of Integer ArrayLists to store the paths and an integer list to store each individual path. Beginning with node 0, it recursively calls the dfs algorithm on each edge in the graph starting from that node, adding the visited nodes to the path. If it reaches the final node, it adds the path to the list of paths before clearing the last element from the path for the next recursive call. Once all edges have been searched, the algorithm returns the list of paths. The overall time complexity is O(N+M) where N is the number of vertices and M is the number of edges, because it iterates through the list of vertices, visiting each edge once. The space complexity is O(n+m), where n is the size of the ArrayList of paths to be output and m is the size of the longest path ArrayList.
